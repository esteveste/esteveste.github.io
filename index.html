<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
    <meta charset="utf-8">
    <title>Bernardo Esteves</title>
    <script src="utils/three.min.js"></script>
    <script src="utils/TrackballControls.js"></script>
    <script src="utils/Detector.js"></script>
    <script src="utils/gyronorm.complete.min.js"></script>

    <meta name="theme-color" content="#000000">
    <!--<link rel="icon" sizes="192x192" href="nice-highres.png">-->


    <script src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.1/jquery.min.js"></script>
    <style>
        body {
            margin: 0 0;
            overflow: hidden;
            background-color: black;
        }
    </style>
</head>

<body>
    <span id="title" style="
    font-size: 6em;
    color: black;
    position: absolute;
    font-weight: 800;
    font-family: monospace;
    padding-left: 4vh;
    top: 2vh;
    ">esteves</span>
    <span id="title2" style="
    font-size: 6em;
    color: white;
    position: absolute;
    font-weight: 800;
    font-family: monospace;
    padding-left: 4vh;
    top: 2vh;
    ">esteves</span>
<!--<script>-->
    <!--init()-->
<!--</script>-->
<script>
    setTimeout(()=>$('#title2').fadeOut(2500),3000);

    var isOver = false;
    function out(){
        if(isOver==false){
            $('#title2').fadeOut();
            // $('#logo1').fadeIn();
        }
    }
    $('span').on({
        mouseenter: function(){
            isOver = true;
            // $('#logo1').fadeOut();
            $('#title2').fadeIn();
        },
        mouseout: function(){
            isOver = false;
            setTimeout(out,1000);
        }
    });
    if ( ! Detector.webgl ) {
        var m = document.getElementById('menu');
        m.style.display = "none";
        Detector.addGetWebGLMessage();
        $('.title').css({
            top: '-10px',
            left: '50%',
            color: '#ddd',
            'margin-left':'-110px'
        });
    }

    var camera, scene, renderer;
    var geometry, material, mesh;
    var mouseX = 0, mouseY = 0;
    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;
    var cnt = 0;
    var meshes = [];

    let group = new THREE.Group();

    function setup() {
        var W = window.innerWidth, H = window.innerHeight;
        renderer = new THREE.WebGLRenderer( { preserveDrawingBuffer: true } );
        renderer.autoClearColor = false;
        renderer.setSize( W, H );
        document.body.appendChild( renderer.domElement );
        camera = new THREE.PerspectiveCamera( 50, W/H, 1, 10000 );
        camera.position.z = 500;
        scene = new THREE.Scene();



        for ( var i = 0; i < 500; i ++ ) {
            var mpx = Math.random() * 1000 - 500;
            var mpy = Math.random() * 1000 - 500;
            var mpz = Math.random() * 1000 - 500;
            var mrx = Math.random() * 2 * Math.PI;
            var mry = Math.random() * 2 * Math.PI;
            var mrz = Math.random() * 2 * Math.PI;
            geometry = new THREE.CubeGeometry( 25, 25, 25 );
            // geometry = new THREE.SphereGeometry( 25, 10, 10);
            material = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true,  wireframeLinewidth: 2 } );
            mesh1 = new THREE.Mesh(geometry, material);
            mesh1.position.x = mpx;
            mesh1.position.y = mpy;
            mesh1.position.z = mpz;
            mesh1.rotation.x = mrx;
            mesh1.rotation.y = mry;
            mesh1.rotation.z = mrz;
            // scene.add( mesh1 );

            material = new THREE.MeshBasicMaterial( { color: Math.random()*0xffffff } );
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.x = mpx;
            mesh.position.y = mpy;
            mesh.position.z = mpz;
            mesh.rotation.x = mrx;
            mesh.rotation.y = mry;
            mesh.rotation.z = mrz;
            // scene.add( mesh );

            meshes[ cnt ] = mesh;
            cnt += 1;

            group.add(mesh1);
            group.add(mesh);
        }
        scene.add(group);
        window.addEventListener( 'resize', onWindowResize, false );
        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
    }
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        // effect.setSize( window.innerWidth, window.innerHeight );
    }
    function onDocumentMouseMove(event) {
        // $('span').text(event.clientX);
        mouseX = ( event.clientX - windowHalfX );
        mouseY = ( event.clientY - windowHalfY );
    }

    function fade() {
        document.removeEventListener('mousemove', onDocumentMouseMove, false);
        setTimeout(()=>$('canvas').fadeOut(2500),500);
        let timer = setInterval(function() {
            if (mouseX>=windowHalfX && mouseY>=windowHalfY){
                clearInterval(timer);
                document.addEventListener( 'mousemove', onDocumentMouseMove, false );

                setTimeout(()=>$('canvas').fadeIn(2000),5000);
            }
            else{
                mouseX+=10;
                mouseY+=10;
            }
        }, 20); // change by 2px every 20ms, about 50 frames per second
    }
    
    
    //GYRO
    var gn = new GyroNorm();

    gn.init().then(function(){
        gn.start(function(data){
            // Process:
            // data.do.alpha	( deviceorientation event alpha value )
            // data.do.beta		( deviceorientation event beta value )
            // data.do.gamma	( deviceorientation event gamma value )
            // data.do.absolute	( deviceorientation event absolute value )

            // group.rotation.x=data.do.beta;
            // group.rotation.y=data.do.alpha;
            if(data.do.alpha!=0 &&data.do.alpha !=0) {


                let alpha;
                if(data.do.alpha>=0 && data.do.alpha<90 ){
                    alpha=90+data.do.alpha;
                }else if(data.do.alpha>=90 && data.do.alpha<270) {
                    alpha=180+90-data.do.alpha;
                }else{
                    alpha=data.do.alpha-270;
                }
                // $('span').text(data.do.beta);
                mouseX =data.do.beta-90;
                mouseY = alpha;
            }


            // data.dm.x		( devicemotion event acceleration x value )
            // data.dm.y		( devicemotion event acceleration y value )
            // data.dm.z		( devicemotion event acceleration z value )

            // data.dm.gx		( devicemotion event accelerationIncludingGravity x value )
            // data.dm.gy		( devicemotion event accelerationIncludingGravity y value )
            // data.dm.gz		( devicemotion event accelerationIncludingGravity z value )

            // data.dm.alpha	( devicemotion event rotationRate alpha value )
            // data.dm.beta		( devicemotion event rotationRate beta value )
            // data.dm.gamma	( devicemotion event rotationRate gamma value )
        });
    }).catch(function(e){
        // Catch if the DeviceOrientation or DeviceMotion is not supported by the browser or device
    });



    function draw() {
        requestAnimationFrame( draw );


        for ( i = 0; i < cnt; i ++ ) {
            mesh = meshes[ i ];
            var time = Date.now() * 0.0005;
            h = ( 360 * ( 1.0 + time ) % 360 ) / 360;
            mesh.material.color.setHSL(h, 0.5, 0.5 );
            //mesh.children[0].materials.color.setHSL(h, 0.5, 0.5 );
        }
        camera.position.x += ( mouseX - camera.position.x ) * .05;
        camera.position.y = THREE.Math.clamp( camera.position.y + ( - ( mouseY - 200 ) - camera.position.y ) * .05, 50, 1000 );
        camera.position.z = (mouseX + mouseY) * 2;
        //camera.position.z = Math.sin( Date.now() * 0.002 ) * 500;
        //camera.position.y = Math.sin( Date.now() * 0.002 ) * 300;
        camera.lookAt(mesh.position);
        renderer.render( scene, camera );
    }
    setup();
    draw();
</script>
</body>

</html>